<?xml version="1.0"?>
<doc>
    <assembly>
        <name>MSPro.CLArgs</name>
    </assembly>
    <members>
        <member name="T:MSPro.CLArgs.ArgumentConverter`1">
            <summary>
                Turns Arguments into a parameter object of a specified type..
            </summary>
        </member>
        <member name="F:MSPro.CLArgs.ArgumentConverter`1._resolvedOptions">
            <summary>
                Get a list of Options unique by their name.
            </summary>
        </member>
        <member name="M:MSPro.CLArgs.ArgumentConverter`1.TryConvert(MSPro.CLArgs.Arguments,System.Collections.Generic.IEnumerable{MSPro.CLArgs.OptionDescriptorAttribute},`0@,System.Collections.Generic.HashSet{System.String}@)">
            <summary>
                Execute the command that is resolved by the verbs passed in the command-line.
            </summary>
        </member>
        <member name="M:MSPro.CLArgs.ArgumentConverter`1.resolvePropertyValue(System.Type,System.Collections.Generic.IReadOnlyCollection{MSPro.CLArgs.Option},System.Collections.Generic.ISet{System.String})">
            <summary>
                Resolves a single property's value. If property is an annotated class it will
                recursively resolve all properties of this class.
            </summary>
            <param name="instanceType"></param>
            <param name="options"></param>
            <param name="unresolvedPropertyNames"></param>
        </member>
        <member name="T:MSPro.CLArgs.Commander">
            <summary>
                The top level class to easily use 'CLArgs'.
            </summary>
        </member>
        <member name="M:MSPro.CLArgs.Commander.#ctor(MSPro.CLArgs.Settings)">
            <summary>
                Create a new Commander instance.
            </summary>
            <param name="settings">Settings used to control CLArgs overall behaviour.</param>
        </member>
        <member name="M:MSPro.CLArgs.Commander.RegisterCommandFactory(System.String,System.Func{MSPro.CLArgs.ICommand},System.String)">
            <summary>
                Manually register (add or update) a Command.
            </summary>
            <remarks>
                Not the command itself is registered but <b>a factory function</b> that
                is used to create a new instance of the Command.<br />
                If there is already a command registered for the same <paramref name="verb" />
                the 'old' command is overridden.
            </remarks>
            <param name="verb">The <see cref="P:MSPro.CLArgs.Arguments.Verbs" /> that is linked to this Command</param>
            <param name="factoryFunc">A factory function that return an instance of <see cref="T:MSPro.CLArgs.ICommand" />.</param>
            <param name="commandDescription"></param>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="verb" /> is null or empty.</exception>
            <example>
                <code>
                Commander c = new Commander(args);
                c.RegisterCommandFactory( "HelloWorld", () => new HelloWorldCommand());
                c.ExecuteCommand();
            </code>
            </example>
            <seealso cref="P:MSPro.CLArgs.Settings.AutoResolveCommands" />
        </member>
        <member name="M:MSPro.CLArgs.Commander.RegisterFunction(System.String,System.Action{MSPro.CLArgs.Arguments},System.String)">
            <summary>
                Directly bind a function to a verb.
            </summary>
            <param name="verb">The Verb</param>
            <param name="func">
                The function that is executed when the verbs passed in the
                command-line (<see cref="P:MSPro.CLArgs.Arguments.VerbPath" /> are equal to the <paramref name="verb" />.
            </param>
            <param name="commandDescription"></param>
            <example>
                <code>
            string COMMAND_LINE = "word1 text2 verb3";
            // Arguments.VerbPath is executed
            var commander = new Commander(new Settings { AutoResolveCommands = false });
            commander.RegisterFunction("word1", word);
            commander.RegisterFunction("word1.text2", text);
            commander.RegisterFunction("word1.text2.verb3", verb);
            commander.ExecuteCommand(args);
            </code>
            </example>
            <exception cref="T:System.ArgumentNullException">In case <paramref name="verb" /> is null.</exception>
            <seealso cref="P:MSPro.CLArgs.Arguments.VerbPath" />
            <seealso cref="P:MSPro.CLArgs.Settings.AutoResolveCommands" />
        </member>
        <member name="M:MSPro.CLArgs.Commander.ResolveCommand(System.String)">
            <summary>
                Resolve a Command implementation by Verb.
            </summary>
            <seealso cref="P:MSPro.CLArgs.Settings.AutoResolveCommands" />
            <seealso cref="M:MSPro.CLArgs.Commander.RegisterCommandFactory(System.String,System.Func{MSPro.CLArgs.ICommand},System.String)" />
            <param name="verb">
                The verb for which and implementation should be resolved.
                IF <c>verb</c> is <c>null</c> the default Command (first registered command) is returned.
            </param>
        </member>
        <member name="M:MSPro.CLArgs.Commander.ExecuteCommand(MSPro.CLArgs.Arguments)">
            <summary>
                Execute the command referenced by <see cref="P:MSPro.CLArgs.Arguments.VerbPath" />.
            </summary>
        </member>
        <member name="M:MSPro.CLArgs.Commander.ExecuteCommand(System.String[],MSPro.CLArgs.Settings)">
            <summary>
                Shortcut and preferred way to use Commander.
            </summary>
            <example>
                Full code:
                <code>
                new Commander(settings).ExecuteCommand(CommandLineParser.Parse(args))
                </code>
            </example>
        </member>
        <member name="T:MSPro.CLArgs.CommandBase`1">
            <summary>
                Provides a convenient way to use command-line for most applications.
            </summary>
            <typeparam name="TCommandParameters">
                The type of the parameter object that is passed to the command.
            </typeparam>
        </member>
        <member name="M:MSPro.CLArgs.CommandBase`1.BeforeArgumentConversion(MSPro.CLArgs.Arguments,MSPro.CLArgs.Settings)">
            <summary>
            </summary>
            <remarks>
                This method is called before any Argument conversion takes place.
                Override this method to add your custom Argument to Property
                <see cref="P:MSPro.CLArgs.Settings.ValueConverters">TypeConverters</see>.<br />
                You may also use this method to
                <see cref="M:MSPro.CLArgs.Arguments.SetOption(MSPro.CLArgs.Option)">add missing options</see>
                to your arguments.
            </remarks>
        </member>
        <member name="M:MSPro.CLArgs.CommandBase`1.BeforeExecute(`0,System.Collections.Generic.HashSet{System.String},MSPro.CLArgs.ErrorDetailList)">
            <summary>
                Make sure everything is set-up and ready to execute the command.
            </summary>
            <remarks>
                Use this method to validate <see cref="!:parameters" />,
                to provide provide dynamic defaults and/or to resolve parameter.<br />
                The method s called immediately before the Command <see cref="M:MSPro.CLArgs.CommandBase`1.Execute(`0)" /> method is called.
                In case, <paramref name="errors" /> contains any value, <see cref="M:MSPro.CLArgs.CommandBase`1.OnError(MSPro.CLArgs.ErrorDetailList,System.Boolean)" /> is called instead of
                <see cref="M:MSPro.CLArgs.CommandBase`1.Execute(`0)" />.
            </remarks>
            <param name="parameters">
                The parameter object (target instance) that will be used to execute the Command.
            </param>
            <param name="unresolvedPropertyNames">
                A <see cref="T:System.Collections.Generic.HashSet`1" /> containing those parameter properties that haven't yet got a value: neither by assigning a
                command-line option nor was there a default value defined in the properties
                <see cref="T:MSPro.CLArgs.OptionDescriptorAttribute" />.
            </param>
            <param name="errors">
                The error object. In case of any error, use <see cref="M:MSPro.CLArgs.ErrorDetailList.AddError(System.String,System.String)" />
                to add your errors to this list.
            </param>
            <seealso cref="M:MSPro.CLArgs.CommandBase`1.OnError(MSPro.CLArgs.ErrorDetailList,System.Boolean)" />
        </member>
        <member name="M:MSPro.CLArgs.CommandBase`1.OnError(MSPro.CLArgs.ErrorDetailList,System.Boolean)">
            <summary>
                Error handler in case of any error.
                <remarks>
                    The default implementation of <see cref="M:MSPro.CLArgs.CommandBase`1.OnError(MSPro.CLArgs.ErrorDetailList,System.Boolean)" /> simply throws an
                    <see cref="T:System.AggregateException" /> in case of any error. You can avoid this by overriding this method.
                </remarks>
            </summary>
            <param name="errors">The errors that have occured.</param>
            <param name="handled">If <c>true</c> the method does nothing anymore, because it expects the errors have been handled.</param>
            <exception cref="T:System.AggregateException">Always</exception>
        </member>
        <member name="M:MSPro.CLArgs.ExtensionMethods.RunIf(MSPro.CLArgs.Settings,System.Diagnostics.TraceLevel,System.Action)">
            <summary>
            Run the code block enclosed in <c>action</c> if trace level allows.
            </summary>
            <param name="settings"></param>
            <param name="level"></param>
            <param name="action"></param>
        </member>
        <member name="M:MSPro.CLArgs.ErrorDetailList.ToString">
            <summary>
                Easy way to get one complete message for all errors
            </summary>
            <returns></returns>
        </member>
        <member name="T:MSPro.CLArgs.Option">
            <summary>
                A command-line Option.
            </summary>
        </member>
        <member name="M:MSPro.CLArgs.Option.#ctor(System.String,System.String)">
            <summary>
                Create a new options.
            </summary>
            <param name="tag">The name of the option.</param>
            <param name="value"></param>
        </member>
        <member name="M:MSPro.CLArgs.Option.#ctor(System.String)">
            <summary>
                Create an unresolved Option.
            </summary>
            <remarks>
                Unresolved means no value has been set.
            </remarks>
        </member>
        <member name="P:MSPro.CLArgs.Option.Key">
            <summary>
                Get the option's Key - which is the tag as it was provided in the command-line,
                or the option's name, after option resolution.
            </summary>
        </member>
        <member name="T:MSPro.CLArgs.OptionResolver">
            <summary>
                Provides support for Option Descriptors.
            </summary>
            <remarks>
                An option as it is parsed from command-line is of type <see cref="T:MSPro.CLArgs.Option" />.<br />
            </remarks>
        </member>
        <member name="F:MSPro.CLArgs.OptionResolver._wellKnownOptions">
            <summary>
                Options with any of these Tags will not be marked as unresolved.
            </summary>
        </member>
        <member name="M:MSPro.CLArgs.OptionResolver.ResolveOptions(MSPro.CLArgs.Arguments,MSPro.CLArgs.ErrorDetailList,System.Boolean,System.Boolean)">
            <summary>
                Resolve all options from command-line by tag into options by name.
            </summary>
            <remarks>
                All <see cref="P:MSPro.CLArgs.Arguments.Options" /> are resolved into an
                OptionByName list, based on the provided list of <see cref="T:MSPro.CLArgs.OptionDescriptorAttribute" />s.
            </remarks>
            <param name="arguments"></param>
            <param name="errors"></param>
            <param name="ignoreCase">If <c>true</c> cases will be ignored when parsing tags.</param>
            <param name="ignoreUnknownTags">
                If <c>true</c> unknown tags provided in the command-line will be ignored.<br/>
                If set to <c>false</c> options provided in the command-line where there is no matching OptionDescriptor
                will be recognized as 'too much' (not known). If there is any, <see cref="!:errors"/> will contain
                the corresponding messages.
            </param>
            <returns>A unique (by name) list of Options.</returns>
        </member>
        <member name="T:MSPro.CLArgs.Arguments">
            <summary>
                The arguments as they were provided as a command-line.
            </summary>
            <remarks>
                An <c>Argument</c> can be either a <see cref="P:MSPro.CLArgs.Arguments.Verbs" />
                or an <see cref="T:MSPro.CLArgs.Option" />.
            </remarks>
        </member>
        <member name="P:MSPro.CLArgs.Arguments.CommandLine">
            <summary>
                The full command-line as it was parsed.
            </summary>
        </member>
        <member name="P:MSPro.CLArgs.Arguments.Verbs">
            <summary>
                The list of verbs in the sequence order
                as they were provided in the command-line.
            </summary>
        </member>
        <member name="P:MSPro.CLArgs.Arguments.VerbPath">
            <summary>
                All Verbs as a '.' concatenated list - namespaced verbs.
            </summary>
            <returns>
                All <see cref="P:MSPro.CLArgs.Arguments.Verbs" /> concatenated by '.', for example, 'HelloWorld.Germany'.<br />
                <c>null</c> in case, no verb was provided in the command-line.
            </returns>
        </member>
        <member name="P:MSPro.CLArgs.Arguments.Options">
            <summary>
                A key-value list of all options provided in the command-line.
            </summary>
            <remarks>
                All option values are <c>strings</c> int he first instance.
                Conversion may happen later.
            </remarks>
        </member>
        <member name="M:MSPro.CLArgs.Arguments.SetOption(MSPro.CLArgs.Option)">
            <inheritdoc cref="M:MSPro.CLArgs.Arguments.SetOption(MSPro.CLArgs.Option)" />
        </member>
        <member name="M:MSPro.CLArgs.Arguments.SetOption(System.String,System.String)">
            <summary>
                Manually add or update an option.
            </summary>
            <remarks>Options are unique by their <see cref="P:MSPro.CLArgs.Option.Key" /></remarks>
        </member>
        <member name="T:MSPro.CLArgs.CommandLineParser">
            <summary>
                Provides the functionality to parse a command-line
            </summary>
            <see cref="T:MSPro.CLArgs.CommandLineParser" />
        </member>
        <member name="M:MSPro.CLArgs.CommandLineParser.#ctor(MSPro.CLArgs.Settings)">
            <summary>
                Create a new instance.
            </summary>
            <param name="settings">
                Provide a <see cref="T:MSPro.CLArgs.Settings" /> instance to control the parsing behaviour:
                <see cref="P:MSPro.CLArgs.Settings.IgnoreCase" />,
                <see cref="F:MSPro.CLArgs.Settings.OptionValueTags" /> and
                <see cref="P:MSPro.CLArgs.Settings.OptionsTags" /> are of interest here.
            </param>
        </member>
        <member name="M:MSPro.CLArgs.CommandLineParser.Parse(System.String[],MSPro.CLArgs.Settings)">
            <summary>
                Shortcut and preferred way to use CommandLineParser.
            </summary>
            <remarks>
                Same as <code>new CommandLineParser(settings).Run(args);</code>.
            </remarks>
            <seealso cref="M:MSPro.CLArgs.CommandLineParser.#ctor(MSPro.CLArgs.Settings)" />
        </member>
        <member name="M:MSPro.CLArgs.CommandLineParser.Run(System.String[])">
            <summary>
                Parse a given command-line.
            </summary>
        </member>
        <member name="F:MSPro.CLArgs.Settings.OptionValueTags">
            <summary>
                Get or set a list of characters that mark the end of an option's name.
            </summary>
        </member>
        <member name="P:MSPro.CLArgs.Settings.IgnoreUnknownOptions">
            <summary>
                Get or set if unknown option tags provided in the command-line should be ignored.
            </summary>
            <remarks>
                If set to <c>true</c> unknown options are ignored.<br />
                Otherwise an error is added to the <see cref="T:MSPro.CLArgs.ErrorDetailList">error collection</see>.
            </remarks>
        </member>
        <member name="P:MSPro.CLArgs.Settings.AutoResolveCommands">
            <summary>
                Automatically resolve commands using <see cref="P:MSPro.CLArgs.Settings.CommandResolver" />
            </summary>
        </member>
        <member name="P:MSPro.CLArgs.Settings.CommandResolver">
            <summary>
                Get or set an object to resolve all known commands (and verbs).
            </summary>
            <remarks>
            The default resolver is
               <see cref="T:MSPro.CLArgs.AssemblyCommandResolver"/>(<b>Assembly.GetEntryAssembly()</b>),
            to find all classes with [Command] annotation in the <c>EntryAssembly</c>.
            </remarks>
        </member>
        <member name="P:MSPro.CLArgs.Settings.OptionsTags">
            <summary>
                Get or set tags which identify an option.
            </summary>
            <remarks>
                A command-line argument that starts with any of these character
                is considered to be an <c>Option</c>.
            </remarks>
        </member>
        <member name="T:MSPro.CLArgs.ValueConverters.FromStringDelegate">
            <summary>
                Convert from <c>string</c> int a
                <paramref name="targetType" />
                .
            </summary>
            <param name="optionValue">The option value of type <c>string</c></param>
            <param name="optionName">
                The name of the property on which the converter value will be set.
            </param>
            <param name="errors">
                The error collection where to add conversion errors.
            </param>
            <param name="targetType">The into which <paramref name="optionValue" /> should be converted.</param>
            <returns>
                The converted value of type
                <param ref="targetType"></param>
            </returns>
            <example>
                <code>
             if (!DateTime.TryParse(optionValue, out DateTime d)) {
                 errors.AddError(optionName,
                     $"Cannot parse the value '{optionValue}' for Option '{optionName}' into a DateTime.");
             }
             return d;
            </code>
            </example>
        </member>
    </members>
</doc>
