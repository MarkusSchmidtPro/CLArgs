{
  "doc/basics.html": {
    "href": "doc/basics.html",
    "title": "Basics",
    "keywords": "Basics In the command-line you can provide Verbs and Options . Verbs and Commands A Verb is a word that determines what your Console Application should do. A Verb is bound to a certain functionality: YourApp.exe ConvertXml ==> MyXmlConverter() . This functionality is implemented as a Command . RegisterCommandFactory( \"ConvertXml\", () => new MyXmlConverter()); or use Annotations (Zero-Coding [ Sample-Code ]) [Command(\"ConvertXml\")] class MyXmlConverter : CommandBase<XmlConverterParameters> { protected override void Execute(XmlConverterParameters ps) { // .... } } NOTE: Verbs are completely optional. If your Console Application has only one single functionality, well, then use CLArgs without Verbs: Arguments arguments = CommandLineParser.Parse(args); var cmd = new MyXmlConverter(); cmd.Execute( arguments); Options An Option is a name-value tag that is parsed from the command-line: --filename=Input.xml --out='outDir\\' --forceOverride Options are converted into Parameters : class XmlConverterParameters { [OptionDescriptor(\"filename\", \"f\", Required = true)] public string Filename { get; set; } [OptionDescriptor(\"out\", \"o\", Required = false, Default = \"out\")] public string OutDir { get; set; } [OptionDescriptor(\"forceOverride\", \"fo\", Required = false, Default = true)] public bool ForceOverride { get; set; } } Verbs and Options Each Verb has its own set of Options , because each Command requires its own Parameters : \"ConvertXml\" => XmlConverter( XmlConverterParameters ps); \"CreateSchema\" => XsdSchemaGenerator( XsdSchemaGenerator ps); Automatic resolution When you provide a Verb in the command-line, CLArgs automatically resolved the related Command. CLArgs then gets the Command Parameter type and converts the command-line arguments into an instance of this type. Finally it executes the command. And all this with a single line of code: Commander.ExecuteCommand(args); What's Next Custom Conversion Dynamic Defaults"
  },
  "doc/competition.html": {
    "href": "doc/competition.html",
    "title": "The Competition",
    "keywords": "The Competition Is CLArgs just another command-line interpreter or parser? Yes, it is another command-line arguments parser. No, it is better than all others (I believe). It is better because all others I found had major disadvantages or missing features so I could not use any of them. I thought it was time to reinvent the wheel! Not the (Flint) stone wheel, not the wooden one and not the rubber one. There are so many command-line interpreters out there. I wanted to invent the wheel with air inside, where you can chose the right pressure you need - one fits all. Let's reinvent the way how to build modern command-line apps. What is a Competitor A Competitor was mentioned in a blog or as a suggestion somewhere. A Competitor does not look as it was a forgotten package in a beta state. It does not have dependencies on a specific run-time. It has a documentation and it contains examples. System.CommandLine - DragonFruit Initially I was quite happy to see that there is an approach from Microsoft. Read the MSDN Article (March 2019) - Parse the Command Line with System.CommandLine Obviously there is a NuGet package for it, that evolved from Alpha 0.3 to Beta 2.0.0-beta1-20303.1 (2020-07-18) in 18 month. I started using it and found out it supports all features I needed but the coding effort was to high and too static with regards to adding new commands or changing / adding a new option to an existing command. You may also read about DragonFruit - there are many articles on the web. But since these articles were written, not much has changed. Somehow it looked like the developers are not convinced it is good enough for a release version and they got stuck in fixing issues, to keep it alive and to have a monthly release. CommandLineParser CommandLineParser was my second choice. Unfortunately, there's support for only one Verb."
  },
  "doc/convertValues.html": {
    "href": "doc/convertValues.html",
    "title": "Custom Conversion",
    "keywords": "Custom Conversion Sample-Code / Sample-Project The command-line is always text. Therefore, an Option value is always of type string - the string as it was provided in the command-line. A Command requires Parameters - a typed object - and in between type / value conversion takes place. CLarg comes with out-of-the-box support for the following Parameter property types: string bool int DateTime Enum If you wanna turn command-line arguments into other object types you have to provide your own converter. For example, the property type FileInfo requires your custom converter. void Main(string[] args) { var settings = new Settings(); settings.ValueConverters.Register(typeof(FileInfo), // Custom Conversion: string to FileInfo (optionValue, optionName, errors, targetType) => new FileInfo(optionValue)); Commander.ExecuteCommand( args, settings)); } ... [OptionDescriptor(\"DestType\", Required = true)] public FileTypes FileTypes { get; set; } // requires custom converter"
  },
  "doc/dynamicDefaultValues.html": {
    "href": "doc/dynamicDefaultValues.html",
    "title": "Dynamic Default Values",
    "keywords": "Dynamic Default Values Sample-Code / Sample-Project In most cases, it is enough to define static default values, which are known during compile-time. [OptionDescriptor(\"count\", Required = false, Default = 1)] However, there are use-cases when you would consider dynamic default values or when a default value depends on another option value. Imagine your app takes two arguments: StartDate [mandatory] and EndDate [optional] If EndDate is not provided in the command-line, it should be Startdate + 7 days . In that case, you can not define a static default value for Enddate because it depends on another value. Resolve Properties To accomplish this, override the BeforeExecute() method in your Command. class DateRangeCommand : CommandBase<FromToCommandParameters> { protected override void BeforeExecute( FromToCommandParameters ps, HashSet<string> unresolvedPropertyNames, ErrorDetailList errors) { if (unresolvedPropertyNames.Contains(nameof(ps.EndDate))) { ps.EndDate = ps.StartDate.AddDays(7); } } } Parameter Validation You would also use this method to perform Parameter validations: static and dynamic validations: protected override void BeforeExecute( FromToCommandParameters ps, HashSet<string> unresolvedPropertyNames, ErrorDetailList errors) { // Check K.O. criteria: do not run command if fail DateTime minStartDate = new DateTime(2020, 1, 1); if (ps.StartDate < minStartDate) { errors.AddError(nameof(ps.StartDate), $\"{nameof(ps.StartDate)} must be greater or equal to {minStartDate:d}, current value: {ps.StartDate:d}\"); } What's next Value conversion - Option (string) Parameter value Error-Handling Additional throughs I decided to have one single method OnResolveProperties to resolve all properties over something like [OptionDescriptor( \"EndDate\", Default => myFunc()] and over single property resolution like resolveProperty( string propertyName, ..) . The reason is: when the resolve property method is called, you can never know which other properties have been resolved. How can you know StartDate has got a value when EndDate is resolved. How can you guarantee, StartDate is resolved before EndeDate ? You can't! With single property resolution you have no control over the sequence of resolution."
  },
  "doc/errorHandling.html": {
    "href": "doc/errorHandling.html",
    "title": "The ErrorDetailList",
    "keywords": "The ErrorDetailList"
  },
  "doc/index.html": {
    "href": "doc/index.html",
    "title": "The Command-Line Mission",
    "keywords": "The Command-Line Mission I have been using many different command-line packages but none of them satisfied my needs. Plug-In concept for Verbs I wanted to have to ability to automatically resolve new verbs. Implement the verb's functionality in its own Assembly and use it without changing or adding something in my void Main() . Sample-Code / Sample-Project Support multiple Verbs I wanted to support multiple verbs, to support commands and subcommands, like SayHello , SayHello Germany , ... . Sample-Code / Sample-Project Parameter class that support sub-classes and inheritance class Parameters : BaseParameters { [OptionSet] public Connection DbConnection { get; set; } [OptionDescriptor(\"DatabaseTableName\", \"t\", Required = false)] public string DatabaseTableName { get; set; } } Sample-Code / Sample-Project Minimum code while having maximum flexibility Zero Code: Commander.ExecuteCommand(args); - if you want. Sample-Code / Sample-Project Static and dynamic (dependend) default values I wanted to have static default values for arguments (during compile-time, by annotation) and also dynamic defaults, resolved during run-time when a default value may depend on another (provided) value. Sample-Code / Sample-Project What's next? Basics See all examples Get started with the Command-Line Runner"
  },
  "index.html": {
    "href": "index.html",
    "title": "Welcome to CLArgs documentation",
    "keywords": "Welcome to CLArgs documentation Master your Modern Console Apps made easy. Create a Command that implements the functionality Define the Command Parameters and let CLArgs convert the command-line arguments and call the Command. TIP: Check-Out the Console App Skeleton to get a complete skeleton for your Console App. static class Program { static void Main(string[] args) { Arguments arguments = CommandLineParser.Parse(args); var cmd = new HelloWorldCommand(); cmd.Execute(arguments); } } class HelloWorldParameters { [OptionDescriptor(\"country\", \"c\", Required = true)] public string Country { get; set; } [OptionDescriptor(\"count\", Required = false, Default = 1)] public int Count { get; set; } } class HelloWorldCommand : CommandBase<HelloWorldParameters> { protected override void Execute(HelloWorldParameters ps) { for (int i = 0; i < ps.Count; i++) Console.WriteLine($\"Hello {ps.Country}!\"); } } This is a very basic example, of what you could do with CLArgs. What's next Explore GitHub and the ReadMe to see all features Get the NuGet Package Explore the examples and read more about CLArgs"
  }
}