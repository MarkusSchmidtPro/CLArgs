{
  "_content/competition.html": {
    "href": "_content/competition.html",
    "title": "The Competition",
    "keywords": "The Competition Is CLArgs just another command-line interpreter or parser? Yes, it is another command-line arguments parser. No, it is better than all others (I believe). It is better because all others I found had major disadvantages or missing features so I could not use any of them. I thought it was time to reinvent the wheel! Not the (Flint) stone wheel, not the wooden one and not the rubber one. There are so many command-line interpreters out there. I wanted to invent the wheel with air inside, where you can chose the right pressure you need - one fits all. Let's reinvent the way how to build modern command-line apps. What is a Competitor A Competitor was mentioned in a blog or as a suggestion somewhere. A Competitor does not look as it was a forgotten package in a beta state. It does not have dependencies on a specific run-time. It has a documentation and it contains examples. System.CommandLine - DragonFruit Initially I was quite happy to see that there is an approach from Microsoft. Read the MSDN Article (March 2019) - Parse the Command Line with System.CommandLine Obviously there is a NuGet package for it, that evolved from Alpha 0.3 to Beta 2.0.0-beta1-20303.1 (2020-07-18) in 18 month. I started using it and found out it supports all features I needed but the coding effort was to high and too static with regards to adding new commands or changing / adding a new option to an existing command. You may also read about DragonFruit - there are many articles on the web. But since these articles were written, not much has changed. Somehow it looked like the developers are not convinced it is good enough for a release version and they got stuck in fixing issues, to keep it alive and to have a monthly release. CommandLineParser CommandLineParser was my second choice. Unfortunately, there's support for only one Verb."
  },
  "_content/fourLevels.html": {
    "href": "_content/fourLevels.html",
    "title": "How to use CLArgs",
    "keywords": "How to use CLArgs There are four levels of using CLArgs . The higher the Level, the more flexible CLArgs will become. Level 1 - Basic Level 1 is a bit more than just string[] args . Simply parse your command-line into Arguments and work with Verbs and Options : c:\\> YourApp --fileName=\"myfile.csv\" --target=XML Arguments arguments = Commander.ParseCommandLine(args); See also Level 1 Details Verbs and Options Console Plugin concept with Verbs and Microsoft Composition Level 2 - Standard Parse the command-line into a typed object and pass it to your Command (as shown in the code above). A Command represents the functionality (that is normally void Main ). However, Commands can be bound to Verbs so that one console app can support multiple functionalities with different argument sets. The Standard Level supports (multiple) Verbs and Options , and it is probably the right choice for most of you. I am using CLArgs at this level. More a about Level 2 Most other command-line solutions I have seen, work between Level 1 and 2. Level 3 - Advanced All those who are still not happy with Level 2 , who need more flexibility or who have other special requirements: a) let me know, what is missing and then enter b) Level 3. CLArgs has several hooks and /or extension points where you can integrate your code, and you can use the CLArgs classes and functions as you want it. More a about Level 3 Level 4 - Expert Check out the source-code and use it for your convenience. Don't forget to let me know what you would make better."
  },
  "_content/index.html": {
    "href": "_content/index.html",
    "title": "Modern Console Application Design",
    "keywords": "Modern Console Application Design dotnet itself is a command-line application and a great example how modern console applications should work: c:\\> dotnet build --help Usage: dotnet build [options] <PROJECT | SOLUTION> Arguments: <PROJECT | SOLUTION> The project or solution file to operate on. If a file is not specified, the command will search the current directory for one. Options: -h, --help Show command line help. -o, --output <OUTPUT_DIR> The output directory to place built artifacts in. ... Support --help. There is one or more Verb(s): build There are several Options , which have a name and a value: output=<OUTPUT_DIR> Options are mandatory or optional Different verbs may require different option \"sets\" Options can be represented by different Tags: -o, --output etc., etc., etc. CLArgs supports all these features and it provides a very flexible and extensible model to work with the command-line. What's next The Mission - what I wanted to accomplish is what you get The four levels of using CLArgs"
  },
  "_content/Level1/index.html": {
    "href": "_content/Level1/index.html",
    "title": "Level 1 - Basic",
    "keywords": "Level 1 - Basic The very first step when you use CLArgs is to parse the command-line: Commander.ParseCommandLine(args) . This will return an Arguments object containing all Verbs and Options from the command-line. using MSPro.CLArgs; static void Main(string[] args) { Arguments arguments = Commander.ParseCommandLine(args); // // Functionality: Display arguments // Console.WriteLine(\">>> Start Functionality\"); Console.WriteLine($\"Command-Line: {arguments.CommandLine}\"); foreach (string verb in arguments.Verbs) { Console.WriteLine($\"Verb='{verb}'\"); } foreach (Option option in arguments.Options) { Console.WriteLine($\"Options[{option.Tag}] = '{option.Value}'\"); } Console.WriteLine(\"<<< End Functionality\"); } See source-code / sample project / all samples . Example Command-Line with two Verbs and three Options (starting with '--'): >>> Start Functionality Command-Line: verb1 verb2 --fileName='c:\\myfile.csv' --target=XML --lines=7 Verb[0] = 'verb1' Verb[1] = 'verb2' Options[fileName] = 'c:\\myfile.csv' Options[target] = 'XML' Options[lines] = '7' <<< End Functionality What's next Verbs and Options Plugin concept with Verbs and Microsoft Composition Level 2"
  },
  "_content/Level1/options.html": {
    "href": "_content/Level1/options.html",
    "title": "Options",
    "keywords": "Options Options are (configuration) values that your application requires to execute a certain functionality. Options start with a tag, which is by default: / or -- or - An Option has a tag and a value (tag=name=key). Options are the parameters for a functionality ( Verb ) Argument.Options is a dictionary, where the Option's name is key. c:\\ > MyApp --Opt1=45` : Code Arguments arguments = Commander.ParseCommandLine(args); : Result arguments.Options[\"Opt1\"] = \"45\" An Option is unique by its name. The Option's name is the Tag (Name=Key=Tag) that was provided in the command-line If the same Option is provided multiple times in the command-line, the last one wins rule is applied. An Option value is always of type string , as it was parsed from the command-line. An Option value can be null (e. g. --Flag ) Update or Add Options You can update or add options when required: use the Arguments.Upsert ( Upsert = UP date or in SERT ) for this purpose. const string OPTION_NAME = \"fileName\"; Arguments arguments = Commander.ParseCommandLine(args); // Check if the 'fileName' option exist - was provided in the command-line bool fileNameProvided = arguments.Options.ContainsKey(OPTION_NAME); Console.WriteLine($\"Option '{OPTION_NAME}' was provided in the command-line: {fileNameProvided}\"); // Set a default Option if not provided // Upsert = Update or Insert = Update or Add if (!fileNameProvided) arguments.UpsertOption(OPTION_NAME, \"default.txt\"); See source-code / sample project / all samples . Preview to Level 2 You will see in Level2 that Option values can have types. For now, and as long as you work with the Arguments object only, Option values are: string , and an Option name/key and its tag is the same. Also in Level2 you will then learn that an Option has one name but it can have multiple tags : Name=\"filename\", tags= \"--f\", \"--fn\", \"--fName\". More to say about Options? Yes, a lot. What's next Level 2 Verbs and Options"
  },
  "_content/Level1/verbsAndOptions.html": {
    "href": "_content/Level1/verbsAndOptions.html",
    "title": "Verbs and Options",
    "keywords": "Verbs and Options If you call Arguments arguments = Commander.ParseCommandLine(args); you get a list of Verbs and a dictionary of Options . Verbs Verbs are single words found in the command line. A Verb starts with a character. A Verb determines which functionality should be executed. Example: c:\\> MyApp word1 text2 verb3 >>> Start Functionality Command-Line: word1 text2 verb3 Verb[0] = 'word1' Verb[1] = 'text2' Verb[2] = 'verb3' <<< End Functionality There is also a VerbPath property that would return word1.text2.verb3 . CLArgs does not worry about what you are doing with these verbs. It is your application that makes use of what you have got. private static void Main(string[] args) { Arguments arguments = Commander.ParseCommandLine(args); switch (arguments.VerbPath) { if (arguments.VerbPath == \"word1\") word(); else if (arguments.VerbPath == \"word1.text2\") text(); else if (arguments.VerbPath == \"word1.text2.verb3\") verb(); else Debug.Fail(\"Don't know what to do!\"); } ... } static void word() => Console.WriteLine(\"Function Word\"); static void text() => Console.WriteLine(\"Function Text\"); static void verb() => Console.WriteLine(\"Function Verb\"); See source-code / sample project / all samples . What's next Plugin concept with Verbs and Microsoft Composition Options Level 2"
  },
  "_content/Level1/verbsWithComposition.html": {
    "href": "_content/Level1/verbsWithComposition.html",
    "title": "Verbs with Microsoft.Composition",
    "keywords": "Verbs with Microsoft.Composition Normally, I use Microsoft's System.Composition NuGet package to realize a Plug-In concept for Verbs . This allows me to annotate a class like follows: // The exported name is the verb! [Export(\"HelloWorld\", typeof(IVerbRunner))] class HelloWorldCommand : IVerbRunner { public void Run(Arguments arguments) => Console.WriteLine(\"This is my HelloWorld command.\"); } [Export(\"HelloGermany\", typeof(IVerbRunner))] class HelloGermanyCommand : IVerbRunner { public void Run(Arguments arguments) => Console.WriteLine(\"This is my HelloGermany command.\"); } I can then use a serviceContainer to resolve any functionality by name (by a Verb). Et voilà: simply create new classes, give them a name and you can use them via a Verb. private static void Main(string[] args) { Arguments arguments = Commander.ParseCommandLine(args); Console.WriteLine($\"Command-Line: {arguments.CommandLine}\"); var configuration // build the container, collect [Exports] = new ContainerConfiguration().WithAssembly(Assembly.GetExecutingAssembly()); var serviceContainer = configuration.CreateContainer(); Console.WriteLine(\">>Start Functionality\"); var command= serviceContainer.GetExport<IVerbRunner>( arguments.Verbs[0]); command.Run( arguments); Console.WriteLine(\"<<< End Functionality\"); } Output will be Command-Line: HelloWorld >>Start Functionality This is my HelloWorld command. <<< End Functionality See source-code / sample project / all samples . Please refer to Microsoft's documentation to get used to System.Composition . Basically all classes annotated with the Export attribute will be collected in the service container. What's next Level 2"
  },
  "_content/Level2/convertValues.html": {
    "href": "_content/Level2/convertValues.html",
    "title": "Value Conversion",
    "keywords": "Value Conversion A explained in Level 1, an Option value is always of type string - the string as it was parsed from the command-line. CLarg comes with out-of-the-box support for the following property types: string int DateTime Enum If you wanna turn command-line arguments (which are strings) into other object you have to provide your own converter: enum FileType { XML, JSON } private class CommandParameters { [OptionDescriptor(\"DestType\", Required = true)] public FileType FileType { get; set; } [OptionDescriptor(\"SourceFile\", Required = false)] public FileInfo SourceFile { get; set; } } The enum is supported out of the box: --DestType=JSON . However, the property type FileInfo requires your custom converter. In your Command constructor add the Type you want to convert to the ValueConverters dictionary and provide a function that takes two parameters to convert the value: public Command() { this.ValueConverters.Add( typeof(FileInfo), (propertyName, optionValue) => new FileInfo(optionValue)); } Command-Line: --DestType=XML --SourceFile=NewFile1.Txt >>> Start Main() FileType: XML FilePath: ....\\bin\\Debug\\netcoreapp3.1\\NewFile1.Txt <<< End Main() TIP: ValueConverters is a dictionary with a Type as the key. You can not only add new converters you can also override the out-of-the-box implementation: this.ValueConverters[typeof(int)] = ( propertyName, optionValue) => int.Parse(optionValue); See source-code / sample project / all samples ."
  },
  "_content/Level2/dynamicDefaultValues.html": {
    "href": "_content/Level2/dynamicDefaultValues.html",
    "title": "Dynamic Default Values",
    "keywords": "Dynamic Default Values In most cases, it is enough to define static default values. However, there are use-cases when you would consider dynamic default values. Imagine your app takes two arguments: StartDate [mandatory] and EndDate [optional] If EndDate is not provided in the command-line, it should be Startdate + 7 days . You can not define a static Default value for Enddate because it depends on another parameter. Don't worry about void Main() it is always the same: ICommand cmd = new Command(); cmd.Execute(arguments); Resolve Properties When CLArgs is doing its magic it must resolve the Options which were provided in the command-line and and it must find an appropriate Property in the target object (Command Parameters). CLArgs is scanning for OptionDescriptorAttributes to find matching properties. [OptionDescriptor(\"StartDate\", Required = true)] public DateTime StartDate { get; set; } [OptionDescriptor( \"EndDate\", Required = false)] public DateTime EndDate { get; set; } CLArgs assumes that all properties which are annotated with an OptionDescriptorAttribute should have got a value: either provided in the command-line or as a static default value. In the example above, EndDate does not have a default value, and in case it was not provided in the command-line, the EndDate property remains unresolved . Before CLArgs calls Command.Execute() method it calls OnResolveProperties() . This method gets the CommandParameters object that was populated with all resolved properties and it gets a list with all unresolved property names. protected override void OnResolveProperties( CommandParameters ps, List<string> unresolvedPropertyNames) { // Check if a property's name is in the list of unresolved if( unresolvedPropertyNames.Contains( nameof(CommandParameters.EndDate))) { Console.WriteLine( $\"Unresolved {nameof(CommandParameters.EndDate)}\"); ps.EndDate = ps.StartDate.AddDays(7); } } protected override void OnExecute(CommandParameters p) { Console.WriteLine( $\"Date Range: {p.StartDate:d}..{p.EndDate:d}\"); } Command-Line: --StartDate=2020-01-01 >>> Start Main() Unresolved EndDate Date Range: 01.01.2020..08.01.2020 <<< End Main() See source-code / sample project / all samples . What's next Value conversion - Option (string) value to property value Error handling Additional throughs I decided to have one single method OnResolveProperties to resolve all properties over something like [OptionDescriptor( \"EndDate\", Default => myFunc()] and over single property resolution like resolveProperty( string propertyName, ..) . The reason is: when the resolve property method is called, you can never know which other properties have been resolved. How can you know StartDate has got a value when EndDate is resolved. How can you guarantee, StartDate is resolved before EndeDate ? You can't! With single property resolution you have no control over the sequence of resolution."
  },
  "_content/Level2/errorList.html": {
    "href": "_content/Level2/errorList.html",
    "title": "",
    "keywords": ""
  },
  "_content/Level2/index.html": {
    "href": "_content/Level2/index.html",
    "title": "Level 2 - Standard",
    "keywords": "Level 2 - Standard Level 1 contained the very basics to parse a command-line and we were using only the Arguments class. On Level 2 I want to introduce some classes and concepts to make CLArgs more powerful (than its competition ). CLArgs has several components / classes to accomplish the Mission . Level 3 describes their purpose and how to use each class individually. For most people, even for me, this would be to complex, however it gives you total control and flexibility. CommandBase CommandBase<T> is the base class that provides all the functionality and flexibility you normally need. A Verb becomes a Command A Command takes parameters Command-Line Arguments : string[] Options : name value (values is of type string) Command Parameters - a typed object specified by the Command There are several ways to turn a Verb into a Command . The examples of Level 1 show two of them: Simple Verbs and the Plugin Concept with Composition . Let's focus on Options and Command Parameters and let's implement a SayHelloCommand that say's times \" Hello \". This is what you have to do: public class Command : CommandBase<CommandParameters> { protected override void OnExecute(CommandParameters p) { for (int i = 0; i < p.Count; i++) { Console.WriteLine($\"{i]}: Hello {p.Country}\"); } } } public class CommandParameters { [OptionDescriptor(\"Country\", Required = true)] public string Country { get; set; } [OptionDescriptor( \"Count\", Required = false, Default = 1)] public int Count { get; set; } } static void Main(string[] args) { Arguments arguments = Commander.ParseCommandLine(args); ICommand cmd = new SayHello.Command(); cmd.Execute(arguments); } Good practice would be, to organize your commands in directories, so that you can have more than just one: There is absolutely nothing that you have to code to convert arguments or whatever. Simply implement your functionality and receive a typed parameter object as you go. Command-Line: --Country=Germany --Count=3 >>> Start Main() 0: Hello Germany 1: Hello Germany 2: Hello Germany <<< End Main() See source-code / sample project / all samples . What's next Dynamic Default Values Value conversion - Option (string) value to property value"
  },
  "_content/mission.html": {
    "href": "_content/mission.html",
    "title": "The Mission",
    "keywords": "The Mission I wanted to have a package that supports all the features listed here . I wanted to have to ability to automatically resolve a new verb. Implement the verb's functionality in its own Assembly and use it without changing or adding something in my void Main() . I wanted to support multiple verbs, to support commands and subcommands, like SayHello , SayHello Germany , ... . I wanted Verbs to become Commands . A Command implements a functionality and it should completely stand for itself - no dependency. Extending my console app should be as easy as adding a new Command class. [Command(\"HelloWorld\")] internal class HelloWorldCommand : CommandBase<HelloWorldParameters> { protected override void Execute(HelloWorldParameters ps) { for (int i = 0; i < ps.Count; i++) Console.WriteLine($\"Hello {ps.Country}!\"); } } internal class HelloWorldParameters { [OptionDescriptor(\"country\", \"c\", Required = true)] public string Country { get; set; } [OptionDescriptor(\"count\", Required = false, Default = 1)] public int Count { get; set; } } c:\\ > MyApp --country=Germany --count=3 I wanted to have static default values for arguments (during compile-time, by annotation) and also dynamic defaults resolved during run-time when a default value may depend on another (provided) value. void OnResolveOptions(CommandParameters ps, List<string> unresolvedOptionNames) { if (unresolvedOptionNames.Contains(nameof(ProfileName))) ps.ProfileName = Path.GetFileNameWithoutExtension(ps.DatFilename); } What's next"
  },
  "_content/UseCases/index.html": {
    "href": "_content/UseCases/index.html",
    "title": "Use-Cases",
    "keywords": "Use-Cases"
  },
  "_content/wordings.html": {
    "href": "_content/wordings.html",
    "title": "Wordings",
    "keywords": "Wordings Args[] = Environment.CommandLine The args[] passed to the Program . Basically the command-line itself. Args can be anything in the beginning, and the first action on it should be private static int Main(string[] args) { ... Arguments arguments = Commander.ParseCommandLine(args);` ... Arguments Arguments is the result when the command-line was parsed. An Argument is either an Option or a Verb . Verb A Verb is initially just a text, that was parsed as a single word from the command-line. Example saveFile Verbs are used to find an appropriate Command implementation that can be executed. Option An Option is a name-value tag that was parsed from the command-line. Basically the values which are passed as parameters to the command. Options values are always strings! Example: --opt1=44 --filename=\"myfile.xml\" Command A Command is the implementation of an action that is finally executed. When an instance of a Command is created it gets the Options . The Command then validates the Options and maps them to the command's Parameters . Parameters A Command gets Parameters which is an object that was build based on the Options."
  },
  "index.html": {
    "href": "index.html",
    "title": "",
    "keywords": ""
  }
}